#  Oracle

在SQL命令行输入： @ 或者 start + 脚本名 即可运行SQL脚本

如： statrt test.sql

```sql
修改密码：
alter user system identified by system;
alter user sys identified by sys;
ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;
创建用户
create user test identified by test;
并给用户赋予权限
grant connect,resource,dba to test;
```



# docker基本使用

容器 = 镜像 + 可读层。并且容器的定义并没有提及是否要运行容器。

```dockerfile
1.查看当前运行的所有容器
docker ps -a
2.停止所有容器（container），这样才能够删除其中的images：
docker stop $(docker ps -a -q)
3.如果想要删除所有容器（container）的话再加一个指令：
docker rm $(docker ps -a -q)
4.查看当前有那些镜像（images）
docker images
5.删除镜像（images），通过镜像（images）的id来指定删除谁
docker rmi <image id>
6.想要删除镜像（images）id为<None>的image的话可以用
docker rmi $(docker images | grep "^<none>" | awk "{print $3}")
7.要删除全部镜像（images）的话
docker rmi $(docker images -q)
8.启动镜像
docker start 镜像名
9.为镜像建立一个来终端交互
docker exec -it 镜像名 bash
```



# 一、基本体系结构

## 1.`Oracle`的体系结构

​		`Oracle`服务器：是一个数据管理系统(`RDBMS`)，它提供开放的, 全面的, 近乎完整的信息管理。由1个数据库和一个（或多个）实例组成。数据库位于硬盘上，实例位于内存中。

## 2.表空间和数据文件

逻辑概念：表空间是由数据文件组成，位于实例上，在内存中。

物理概念：数据文件，在磁盘上（`/home/oracle_11/app/oradata/orcl`目录中的`.DBF`文件）；

​     一个表空间包含一个或者多个数据文件。

### 2.1 段、区、块

​		段存在于表空间中，段是区的集合，区是数据块的集合，数据块会被映射到磁盘块。

## 3.启动数据库服务

注意：通过远程客户端连接oracle服务端必须要启动监听服务，否则客户端连接不上。

```mysql
3 启动oracle服务和连接oracle数据库	
	windows下的oracle的启动:
		启动OracleServiceORCL
		启动home1TNSListener
		
	linux下启动oracle数据库:
		使用linux的oracle用户登陆:	
			sqlplus sys/sys as sysdba
			sqlplus / as sysdba	
			SQL> startup   ---启动数据库服务
			SQL> shutdown immeidate   ----关闭数据库服务			
	       	   
	       	   启动监听服务: 
	       	    	lsnrctl start
	linux下停止oracle数据库:
	           停止监听服务:  
					lsnrctl stop
	
```

## 4.如何登陆数据库服务

```mysql
使用sqlplus登陆oracle数据库:
	 	普通用户登陆:  sqlplus scott/tiger@192.168.10.145/orcl
	 	sys用户登陆:  sqlplus sys/sys as sysdba
	    解锁用户:alter user scott account unlock;
	    加锁用户:alter user scott account lock;
	    修改用户密码: password scott
	    	alter user scott identified by xxxxx;
	    查看当前的语言环境: 
	    	select userenv('language') from dual;
```

# 二、基本`SQL`语句

## 1.`sqlplus`的基本操作

```mysql
显示当前用户： show user;
查看当前用户下的表：select * from tab;		
	tab:	数据字典（记录数据库和应用程序源数据的目录），包含当前用户下的表。
查看员工表的结构：desc emp;	
设置行宽：set linesize 120;
设置页面：set pagesize 100;
设置员工名列宽：col ename for a20			(a表示字符串)
设置薪水列为4位数子：col sal for 9999		(一个9表示一位数字)
```



`sqlplus`常用的set命令

```
set echo on         -------设置运行命令是是否显示语句

set feedback on/off -------设置是否显示“已选择XX行”

set colsep |        -------设置列与列之间的分割符号

set pagesize 100    -------设置每一页的行数

set serveroutput on ----设置允许显示输出类似dbms_output

set heading on/off  ------设置是否显示列名

set timing on/off   ------设置是否显示“已用时间：XXXX”

set time on/off     ----------设置显示当前时间

set autotrace on    ------设置允许对执行的sql进行分析
SET AUTOTRACE OFF：不生成AUTOTRACE 报告。这是缺省模式
SET AUTOTRACE ON EXPLAIN：AUTOTRACE仅仅显示优化器运行路径报告
SET AUTOTRACE ON STATISTICS：仅仅显示运行统计信息
SET AUTOTRACE ON：包括运行计划和统计信息
SET AUTOTRACE TRACEONLY：同SET AUTOTRACE ON，可是不显示查询输出 

set verify off   ------可以关闭和打开提示确认信息old 1和new 1的显示. 

set colsep ''    ------域输出分隔符

set linesize 4000 -----输出.. 

SET NUMWIDTH 12   --输出NUMBER类型域长度。缺省为10

```



## 2.基本的`select`语句

```sql
Select语句的整体形式：
select col1, col2…  --列 
	from table_name  --表
	where condition --条件表达式
group by col… --分组数据
having condtion --分组条件
order by col…  --排序

其语法格式为：
SELECT  *|{[DISTINCT] column|expression [alias],...}  FROM table;
案例
 1查询所有员工的所有记录
        select * from emp;
        select empno, ename, job, mgr, hiredate, sal, comm, deptno from emp;
     说明：尽量使用列名，用列名代替* (oracle 9i之前不同， 之后一样)
 2 查询员工号、姓名、薪水
select empno, ename, sal from emp;
     3 查询员工号、姓名、薪水和年薪
        select empno, ename, sal, sal*12 from emp;
      说明：select语句中可以使用表达式
     注意：在执行sql语句的时候，执行 / 会执行上一次执行的语句。

若在写sql语句的时候, 写错了, 可以使用c（change）命令来修改. 默认, 光标闪烁位置指向上一条SQL语句的第一行。输入 2 则定位到第二行。
c  /错误关键字/正确关键字 ↙ 
使用“/”来执行修改过的SQL语句
例如：错误输入: select empno, ename, sal, sal * 12 
						   form emp;   （“from”书写错误，该错误位于整条SQL语句的第二行）
（1）	输入：2↙  终端提示：2* from emp
（2）	输入：c  /form/from ↙		终端提示：2* from emp (意为改正后的sql语句样子)
（3）	输入：/↙ 

也可以使用ed(或者edit)命令来修改
ed ↙弹出系统默认的文本编辑器，(如记事本)
修改、保存、退出、执行“/”。

	使用edit打开文件编辑sql语句:
如果sql语句很长, 可以分行编写或者用ed命令打开一个文件, 
然后在文件中编写sql语句, 注意, sql语句末尾不要加;  , 然后换行加上/表示结束.

	若想将显示结果保存到文件中:
spool命令:
     spool d:\result.txt;
	 select * from emp;
	 spool off;

使用别名：
别名：as
案例：查询员工号，姓名，月薪，年薪 
select empno as "员工号", ename "姓名", sal 月薪, sal*12 年薪 from emp;

说明：关键字as写与不写没有区别； ""有与没有取决于别名中是否有空格，建议在用别名的时候加上""。

DISTINCT---重复记录只取一次
案例：									
select deptno from emp;	
select DISTINCT deptno from emp;
select job from emp;
select distinct job from emp;

select distinct deptno, job from emp;
说明: DISTINCT的作用范围不是距离它最近的列, 而是后面的所有的列。

```

```sql
1 查询所有员工的所有记录
	select * from emp;

2 查询员工号，姓名，月薪，奖金，年薪
	select empno, ename, sal, comm, sal*12 from emp;
	使用select * 和 select 列名的区别: 使用select *会先查有哪些列, 影响效率

3 对案例2使用别名:
	select empno, ename, sal as 工资, comm 奖金, sal*12 "年 薪" from emp;

	关于别名的结论: 
		as可以省略
		如果别名中间有空格, 需要使用""引起来

4 查询员工号，姓名，月薪，奖金，年薪，年收入
	select empno, ename, sal, comm, sal*12 年薪, sal*12+nvl(comm, 0) 年收入 from emp;
	结论: 
		1 包含有null的表达式都为空
		2 nvl的用法: nvl(a, b): 如果a为空, 则取b的值.

5 查看员工表不同的部门编号
	select distinct deptno from emp;

6 查看不同部门的不同工种
	select distinct detpno, job from emp; 
	结论:distinct的作用范围??
		distinct作用于后面出现的所有的列.
		
7 输出计算表达式 3+20*5，显示当前日期  sysdate
	select 3+20*5, sysdate from dual;
	注意: dual表是一个伪表, 主要是为了满足sql的语法规定
```

### 2.1 比较运算符

```sql
1 使用比较运算符: > >= < <= != (<>) between and 
  案例:
  1 查询10号部门的员工信息
  	select * from emp where deptno=10;
  							 
  2 查询员工名字为king的员工信息
  	select * from emp where ename = 'KING';
  			     
  	结论: 表中的列的值是区分大小写的; 但是关键字不区分大小写
  			  
  3 查找薪水不等于1250员工的信息
  	select * from emp where sal!=1250;
  	select * from emp where sal<>1250; 				 			 
  4 查询入职日期为1981年11月17日的员工信息
  	select * from emp where hiredate='1981-11-17'; --查询错误
  	select * from emp where hiredate='17-11月-81';
  				
  查询当前使用的日期格式: 
  	select * from v$nls_parameters;
  修改日期格式: 
  	alter session set NLS_DATE_FORMAT='yyyy-mm-dd';
  修改成原有的格式: 
  	alter session set NLS_DATE_FORMAT='DD-MON-RR';	
  				  				 
 说明: 需要注意日期格式, 默认是DD-MON-RR
  			  
  5 查找工资介于1000-2000之间的员工信息
  	select * from emp where sal>=1000 and sal<=2000;
select * from emp where sal between 1000 and 2000;
  			   结论: between and是闭区间
```

### 2.2`where`条件

#### 2.2.1 在where条件中使用逻辑运算符

```sql
在where条件中使用逻辑运算符: or and not 	
案例:
  1 查询10号部门或者20部门的员工信息
	select * from emp where deptno=10 or deptno=20;	
			
  2 查询10号部门员工工资为1300的员工信息
	select * from emp where deptno=10 and sal=1300;
				 
  3 查询81年2月(含2月)至82年2月(不含2月)入职的员工信息(大于等于81年2月1日，小于等于82年1月31日)
	说明: 注意日期格式问题,注意月份单月不要在前面加0,否则会报错
	select * from emp where hiredate>='1-2月-81' and hiredate<='31-1月-82';
	select * from emp where hiredate between '1-2月-81' and '31-1月-82';
	
	结论: 关于and or 操作符的sql优化问题?
		where条件在进行逻辑表达式计算的时候,是从右往左进行的, 所以对于and来说, 要把容易出现假的放在最右边, 对于or来说, 要把容易出现真的表达式放在最右边.
		where a and b and c and d;
		where a or b or c or d;

  4 查询奖金为空的员工信息-null
	select * from emp where comm=null; --不正确的写法
 	select * from emp where comm is null;
							  		
  5 查询奖金不为空的员工信息
	select * from emp where comm!=null;
	select * from emp where comm is not null;
				
	结论: 关于null的在where条件中使用的结论?
		where条件后面为空应该用is null
		where条件后面不为空使用is not null
			
	分析下面的sql语句:
		select * from emp where deptno=10 or deptno=30 and sal=1250;
	
	注意: 在有or和and的where条件中, and的优先级比or高, 所以若表示10部门或者20部门, 且sal为1250的, 应该
	select * from emp where (deptno=10 or deptno=30) and sal=1250;
	结论: 在where条件表达式中有or的时候, 应该使用()括起来 
```

#### 2.2.2在where条件中使用in

```sql
3 在where条件中使用in  --in后面是一个集合		    
案例:
  1 查询部门号是10或者20的员工信息
	select * from emp where deptno=10 or deptno=20;
	select * from emp where deptno in(10,20);

  思考: 可以在in的集合中使用null吗?
	select * from emp where deptno in(10,20,null);
	select * from emp where deptno=10 or deptno=20 or deptno=null;
			
  2 查询不是10和20号部门的员工信息
select * from emp where deptno!=10 and deptno!=20;
select * from emp where deptno not in(10,20);
			  
	思考: 若not in的集合中有null会怎么样呢?
select * from emp where deptno not in(10,20,null);

select * from emp where deptno!=10 and deptno!=20 and deptno!=null;
			  
not in后面不能出现null
```

#### 2.2.3在where条件中使用like--模糊查找

```sql
4 在where条件中使用like--模糊查找, 其中: '%'匹配任意多个字符。'_'匹配一个字符  escape--转义字符		         
	案例:
		1 查询员工首字母是S的员工信息
		  select * from emp where ename like 'S%';	 
			
		2 查询员工编号为79开头的员工信息
		  select * from emp where empno like '79%'; 
			
		3 查询名字为四个字母长度的员工信息
		  select * from emp where ename like '____'; 
			
	    插入一条记录, 用于测试转义字符，转义字符可以自己设置
		insert into emp (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
		values (1000, 'TOM_CAT', 'CLERK', 9999, to_date('23-01-1982', 'dd-mm-yyyy'), 1200.00, null, 10);   
		 4 查询员工姓名带_的员工信息
select * from emp where ename like '%\_%' escape '\'; 
```

### 2.3 排序--使用order by关键字

```sql
基本格式:
	select  ... from ... where condition order by colname|alias|expr|number(序号)
  	order by有两种排序方法; 一种是升序, 一种是降序: 默认是升序的(asc), 降序为desc
```

#### 2.3.1 使用列名进行排序

```sql
案例: 
  1 员工信息按入职日期先后排序
  	select * from emp order by hiredate asc;
  	select * from emp order by hiredate;  --asc可以省略不写
  
  2 员工薪水按从大到小排序
  	select * from emp order by sal desc;
  				  				
  3 查询员工信息按奖金逆序
  	select * from emp order by comm desc;
  	select * from emp order by comm desc nulls last;
  	注意: null值表现为无穷大, 可以使用nulls last来使null放在最后
  			
  4 员工信息按部门升序、薪水降序排列
  	select * from emp order by deptno, sal desc ;
  根据排序结果得出结论:
  	asc和desc作用于最近的前面的一列
  	按照多个列进行排序的时候, 先按照第一列进行排序, 若第一列相同,则按照第二列排序	
```

#### 2.3.2  使用序号进行排序(并说明什么序号)

```sql
案例:
   1 查询员工编号, 员工姓名和工资, 按照序号(工资)进行排序
      select empno, ename, sal from emp order by 3;	 
      序号: select后面出现的列的次序, 次序从1开始.
```

#### 2.3.3 使用别名进行排序

```sql
按员工的年收入进行排序
	select empno, ename, sal, sal*12+nvl(comm, 0) yearcomm from emp order by yearcomm;
```

#### 2.3.4 使用表达式进行排序

```sql
按照员工的年薪进行排序
	select empno, ename, sal, sal*12  from emp order by sal*12;	 
```

## 3.单行函数

单行函数:只对针对一行进行, 返回一行记录

### 3.1 字符串相关函数

```sql
	1 lower 小写, upper 大写, initcap	单词的首字母大写
	  select lower('HELLO WORLD') "小写", upper('Hello world') "大写", initcap('hello world') "首字母大写" from dual;
	
	2 concat(连接符||)
	  select concat('hello ','world') from dual;
	  **注意: concat函数只能连接两个字符串, 若想连接三个的话只能嵌套调用:
	  	select concat(concat('hello ','world'), ' nihao') from dual;
      	select 'hello ' || 'world ' || 'nihao' from dual;
      **注意: || 可以连接多个字符串, 建议使用||来连接字符串.
    
      **总结: concat只能用于两个字符串的连接, ||可以用于多个字符串的连接, 在使用的使用建议尽量的使用||.
      
	3 substr(str,pos,len)截取字符串
	  select substr('helloworld',1,3), substr('helloworld',1), substr('helloworld',-3) from dual;
	  **总结:pos是从1开始的, 若len为0表示从pos开始, 截取到最后, 若pos为负数, 表示从末尾倒数开始截取,
	  
	4 instr(str, substr):判断substr是否在str中存在, 若存在返回第一次出现的位置, 若不存在则返回0
	  select instr('hello llo', 'llo'),  instr('hello llo', 'ow')from dual;
	
	5 lpad和rpad--l(r)pad(str, len, ch):返回len长度的字符串, 如果str不够len的话, 在左(右)填充ch这个字符
	  select lpad('aaaa', 10, '$'), rpad('aaaa', 10, '#') from dual;
	 
  	6 trim:去掉首部和尾部的空格,中间的空格不去掉
	  select 'aaa'||trim('  hello world  ')||'bbb' from dual;
      trim(c from str):去掉str中的c字符
      select trim('x' from 'xxxxxhello worldxxxxx') from dual;
    
  	7 replace(str, old, new):将str字符串中的old字符串替换成new字符串
      select replace('hello world','llo','yy') from dual;
      
    8  length和lengthb
      select length('hello world') 字符数, lengthb('hello world') 字节数 from dual;
	  select length('哈喽我的') 字符数, lengthb('哈喽我的') 字节数 from dual; 
	  注意:对于length函数一个汉字是一个字符, 对于lengthb函数,一个汉字占两个,
     		这两个函数对于普通字符串没有什么区别.
```

### 3.2 数值函数

```sql
1 round: 四舍五入
    select round(45.926, 2) 一, round(45.926, 1) 二, 		round(45.926, 0) 三,  round(45.926, -1) 四, 		round(45.926, -2) 五 from dual;
    
      trunc: 截取
    select trunc(45.926, 2) 一, trunc(45.926, 1) 二, trunc(45.926, 0) 三,  trunc(45.926, -1) 四, trunc(45.926, -2) 五 from dual;
  
2 mod 求余数
    select mod(1600, 300) from dual;
    
3 ceil:向上取整
    floor:向下取整
    select ceil(121/30), floor(121/30) from dual;
```

### 3.3 转换函数

![img](E:\typroa_pic\clip_image002.jpg)

```sql
1 to_char和to_number
  	 	--把薪水转换为本地货币字符型
	select empno,sal,to_char(sal,'L9,999') from emp;
			--把上述某个结果转回数值型
	select to_number('￥2,975','L9,999') from dual;
				
2 --to_char 与 to_date 
		 --显示 "yyyy-mm-dd hh24:mi:ss 今天是 星期几"
	select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss "今天是" day') from dual;
		 --将上述输出字符串反转回日期
	select to_date('2017-12-04 01:12:48 今天是 星期一', 'yyyy-mm-dd hh24:mi:ss "今天是" day') from dual;       
     --查询1981-11-17日入职的员工信息:
    select * from emp where to_char(hiredate, 'YYYY-MM-DD')='1981-11-17';
	select * from emp where hiredate = to_date('1981-11-17', 'YYYY-MM-DD');
    
    oracle的隐式转换和显示转换:
		select 11+'22' from dual;
		select 11+to_number('22') from dual;
		对于select 11+'22' from dual; 会做隐式转换, 将'22'转换成22

		select '11' || 22 from dual;
		select '11' || to_char(22) from dual;
		对于select 11+'22' from dual; 会做隐式转换, 将22转换成'22'
		
		select 11+'1a' from dual;  --报错, 1a不是数字, 所以不能转
		**总结: 当没有明确转换函数的时候, 如果类型不一致, 会进行隐式转换, 隐式有一个前提, 它必须能转换, 但应尽量避免隐式转换。

```

### 3.4 时间和日期函数

```sql
 --显示当前的系统日期
    select sysdate from dual;
    
  --显示当前的系统日期显示到秒  
    select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') from dual;
    
  --显示当前日期星期几
  	select to_char(sysdate, 'day') from dual;
  	
  --显示昨天，今天，明天--oracle日期型+1代表加一天
  	select sysdate-1 昨天,sysdate 今天,sysdate+1 明天 from dual;
	
  --计算员工工龄 可以按日，周，月，年 日期差减方法
	select empno,ename,sysdate-hiredate 日,(sysdate-hiredate)/7 周,(sysdate-hiredate)/30 月,(sysdate-hiredate)/365 年 from emp;

  --日期函数 months_between  add_months  last_day  next_day
    select empno, ename, months_between(sysdate,hiredate), (sysdate-hiredate)/30 月 from emp;
    
  --add_months:增加月份
  	select add_months(sysdate, 2) from dual;
  	
  --求明年的今天		
  	select add_months(sysdate,12) from dual;

  --last_day:最后一天--指定日期所在月份的最后一天
    select last_day(sysdate) from dual;
    
  --next_day:求指定日期的下一个星期几
    select next_day(sysdate, '星期一') from dual;
    
  --round、trunc 对日期型数据进行四舍五入和截断	
	select round(sysdate, 'month'), round(sysdate, 'year') from dual;
	select trunc (sysdate, 'month'), trunc(sysdate, 'year') from dual;
```

## 4.条件表达式

```mysql
case ... when：	是一个表达式，其语法为：
CASE expr  WHEN comparison_expr1 THEN return_expr1
            [WHEN comparison_expr2 THEN return_expr2
            WHEN comparison_exprn THEN return_exprn
            ELSE else_expr]
END

```

案例: 老板打算给涨工资，总裁1000，经理800，普通员工400，将涨前、涨后薪水列出

```sql
case when	
	select empno,
	       ename,
	       job,
	       sal "涨前薪水",
	       case job
	         when 'PRESIDENT' then
	          sal + 1000
	         when 'MANAGER' then
	          sal + 800
	         else
	          sal + 400
	       end "涨后薪水"
	  from emp;
```

```mysql
decode：是一个函数，其语法为：
DECODE(col|expression, search1, result1 
      			   [, search2, result2,...,]
      			   [, default])
```

```sql
select empno,
        ename,
        job,
        sal "涨前薪水",
        decode(job,
               'PRESIDENT',
               sal + 1000,
               'MANAGER',
               sal + 800,
               sal + 400) "涨后薪水"
   from emp;
```

## 5.分组函数

分组函数:也称之为组函数或者聚合函数, oracle提供的常用的分组函数有:sum, avg, count, max, min

```sql
案例:
	1 统计员工总数
		select count(emp no) from emp;
		
	2 统计工种总数
		select count(job) from emp;
		select count(distinct job) from emp;
		
	3 求员工的平均工资
		select avg(sal) from emp;
	
	4 求员工的平均奖金
		select avg(comm), sum(comm)/count(comm), sum(comm)/count(empno) from emp; 
				
	5 求员工表中最高工资和最低工资
		select max(sal), min(sal) from emp;
			
	6 如何去掉分组函数的滤空功能呢??  --提示: nvl函数
		count(nvl(comm,0));
		结论: 分组函数具有滤空功能.
```

## 6.分组数据

```sql
基本格式 : select ..., count() from emp where ... group by .. 
	说明: 按照group by 后给定的表达式，将from后面的table进行分组, 针对每一组, 使用组函数。
```

```sql
案例:
  1 统计各个部门的平均工资？
	select deptno, avg(sal) from emp group by deptno;
	--最终查询结果与所查列的分类结果有关
	
  2 统计各个部门不同工种的平均工资?
	select deptno, job, avg(sal) from emp group by deptno, job;	
	结论: 请思考通过案例1和案例2得出什么样的结论??  select后面的列和group后面的列有什么关系?
	select a, b, c.., count(f) from table group by a, b, c
	select后面没有出现在分组函数中的列名, 一定要出现在group by子句中.
	在group by子句中出现的列, 不要求一定出现在select后面的列中
		
  3 统计各个部门平均工资高于2000?
	select deptno, avg(sal) from emp group by deptno having avg(sal)>2000;
	
--结论:对分组数据进行过滤, 不能够使用where, 应该使用having
			
  4 求10号部门员工的平均薪水
	方法1:	
	select deptno, avg(sal) from emp where deptno=10 group by deptno;

	方法2:  
	select deptno, avg(sal) from emp group by deptno having deptno=10;
  	结论:比较两种方法, 应该优先使用那种方法??
 		第一种方法好, 原因是第一种是先对整个表的数据进行过滤, 然后在分组统计;
 		而第二种方法, 是先对整个表进行分组统计, 然后再过滤,如果表的数据量很大, 第一种方法效率要高于第二种. 
		
  使用分组函数统计分组数据*-不当的情况:
 	select deptno, job, avg(sal) from emp group by deptno;
 	select deptno, avg(sal) from emp group by deptno, job;
 			
  where和having:
 	1 where用于对数据的第一次过滤, having只能用于分组数据之后的过滤
 	2 如果where和having同时出现了, 则where应该出现在having前面.
	
```

## 7.多表查询

--笛卡尔积(作用是处理多表查询)
  笛卡尔积行数=A表的行数*B表的行数
  笛卡尔积列数=A表的列数+B表的列数

  笛卡尔积的数据集合中有一些是无效的数据, 需要进行过滤, 
  对于有2个表的的笛卡尔积, 需要一个条件, 对于n个表需要n-1个条件.

```sql
--等值连接(结合笛卡尔积讲解)
  --查询员工信息：员工号 姓名 月薪(emp)和部门名称(dept)
  分析: 
  	员工号 姓名 月薪 这三个字段在emp表中, 部门名称在dept表中
  	select e.empno, e.ename, e.sal, d.dname from emp e, dept d where e.deptno=d.deptno;
  	

--不等值连接(结合笛卡尔积讲解)
	--查询员工信息：员工号 姓名 月薪(emp) 和 薪水级别(salgrade表)
	select e.empno, e.ename, e.sal, s.grade from emp e, salgrade s where e.sal between s.losal and s.hisal;

--按部门统计员工人数, 显示如下信息： 部门号 部门名称 人数 
	select d.deptno, d.dname, count(e.empno) from emp e, dept d where e.deptno=d.deptno group by d.deptno, d.dname;
  		
	部门表中40号部门没有被统计上, 如何将40号部门也统计上呢???          
--右外连接 
select d.deptno, d.dname, count(e.empno) from emp e, dept d where e.deptno(+)=d.deptno group by d.deptno, d.dname;
--  +号加在数据少的那一方
  解释一下count(*)和count(e.empno)的区别
  count(*): 只要一行中有一个字段不为空就被统计上
  count(e.empno): 只有e.empno不为空才会被统计上	
	 
--左外连接
select d.deptno, d.dname, count(e.empno) from emp e, dept d where d.deptno=e.deptno(+) group by d.deptno, d.dname;
	
--自连接
--查询员工信息：xxx的老板是 yyy
   分析: emp表中的mgr列表示员工的老板的员工编号, 可以将emp表分别看做员工表和老板表, 员工表的老板是老板表的员工:
 select e.ename || ' 的老板是 ' ||  nvl(b.ename, ' HIS WIFE') from emp e, emp b where e.mgr=b.empno(+);
```

## 8.子查询

### 8.1单行子查询

```sql
--查询比SCOTT工资高的员工信息
	  分析: 可以分两部查找,
	  	 第一步: 查找SCOTT的工资
	  	 	select sal from emp where ename = 'SCOTT';  ---3000.00

	  	 第二步: 将上一步得到的结果作为第二部查询的条件
			select * from emp where sal>3000;
	  	 
	  	 可以使用子查询方法将两步合成一步: 
			select * from emp where sal>(select sal from emp where ename = 'SCOTT');
```



```sql
--关于子查询的注意事项:
1  合理的书写风格 (如上例，当写一个较复杂的子查询的时候，要合理的添加换行、缩进), 可以借助PL/SQL Developer工具

2  使用小括号

3  主查询和子查询可以是不同表，只要子查询返回的结果主查询可以使用即可
--查询部门名称是"SALES"的员工信息:
	分析: 部门名称在dept表中, dept表与emp表是通过deptno联系在一起的.
	
--使用子查询
	 select * from emp where deptno=(select deptno from dept where dname='SALES');
--使用多表查询
	 select e.* from emp e, dept d where e.deptno=d.deptno and d.dname='SALES';

4 可以在主查询的where、select、having、from后都可以放置子查询
  a 在select后使用子查询的情况: 
	查询10号部门员工号, 员工姓名, 部门编号, 部门名称
	  select e.empno, e.ename, e.deptno,(select dname from dept where deptno=10) from emp e where e.deptno=10;
	--注意点: 在select后面使用子查询必须保证子查询结果只返回一条记录.

  b 在having后面使用子查询的情况:
	查询部门平均工资高于30号部门平均工资的部门和平均工资
	  1 先查询30号部门的平均工资
	    select avg(sal) from emp where deptno=30;
	  2 查询每个部门的平均工资
	    select deptno, avg(sal) from emp group by deptno;
	  3  
	    select deptno, avg(sal)
		from emp
		group by deptno
		having avg(sal) > (select avg(sal) from emp where deptno = 30);

--思考题?
   查询员工的姓名、薪水和年薪?  
    select * from ____________;
    select * from (select ename, sal, sal*12 from emp);
    总结: 可以将查询的结果集当成一张表来使用.也就是说, from后面既可以是表名, 也可以是select查询的结果集.

  c 在where后使用子查询的情况:
--查询比平均工资高的员工的信息?
    1 查询平均工资
      select avg(sal) from emp;
    2 select * from emp where sal>2073;
    合成一步:
    	select * from emp where sal>(select avg(sal) from emp);


  d 在having后使用子查询的情况:
	--查询最低薪水高于30号部门最低薪水的部门及其最低薪水
    1 先得到30部门的最低薪水
      select min(sal) from emp where deptno=30;  --950
    2 得到各个部门的最低薪水
      select deptno, min(sal) from emp group by deptno;
    3 使用条件进行过滤
  	  select deptno, min(sal)
	  from emp
	  group by deptno
	  having min(sal) > 950;

     将三步合并写成: 
      select deptno, min(sal)
	  from emp
	  group by deptno
	  having min(sal) > (select min(sal) from emp where deptno = 30);

5 不可以在主查询的group by后面放置子查询 (SQL语句的语法规范)

6 强调：在from后面放置的子查询(***), from后面放置是一个集合(表、查询结果)

```

### 8.2 多行子查询

```sql
1 单行子查询只能使用单行操作符, 多行子查询只能使用多行操作符(前面的> < = 都是单行操作符, 接下来说的是多行操作符)多行操作符有 IN  ANY(任意一个)  ALL （所有）

--查询部门名称为SALES和ACCOUNTING的员工信息
	select * from emp where deptno in (select deptno from dept where dname in ('SALES', 'ACCOUNTING'));

--查询薪水比30号部门任意一个(某一个 ANY )员工高的员工信息
	select * from emp where sal >(select min(sal) from emp where deptno=30);
	select * from emp where sal >(select sal from emp where deptno=30); --错误
	select * from emp where sal >any(select sal from emp where deptno=30);

--查询比30号部门所有人工资高的员工信息
	select * from emp where sal>(select max(sal) from emp where deptno=30);
	select * from emp where sal>all(select sal from emp where deptno=30);

2 一般不在子查询中使用order by, 但在Top-N分析问题中，必须使用order by  

3 一般先执行子查询(内查询)，再执行主查询(外查询)；但是相关子查询除外

4 子查询中的null值
--查询不是老板的员工信息
  分析: 可以先查询谁是老板
  select distinct mgr from emp;
  select * from emp where empno not in (select distinct mgr from emp);

  select * from emp where empno not in (select distinct mgr from emp where mgr is not null);

  总结: not in 后面集合中不能出现null
  empno not in(a, b, null)---> empno!=a and empno!=b and empno!=null;
```

## 9.集合运算

```sql
union 两个集合相同的部分保留一份
union all 两个集合相同的部分都保留
intersect 两个集合交集只保留相同的部分
minus  集合A-集合B，减去A和B都有的部分, 保留A中与B不同的部分
	
select * from emp where deptno = 10 union select * from emp where deptno=20;

select * from emp where deptno = 10 union select * from emp where deptno in(20,10);

select * from emp where deptno = 10 union all select * from emp where deptno in(20,10);

select * from emp where deptno = 10 intersect select * from emp where deptno in(20,10);

select * from emp where deptno in(10,30) minus select * from emp where deptno in(20,10);
	
	总结: 使用集合运算要保证列数一样多, 前后的列的类型要一致
```

# 三、数据处理

## 1.sql语言的类型

```sql
	DML data manipulation language  数据操作语言，对应增删改查
	DDL  data definition language  数据定义语言 create, drop, truncate
	DCL  data control language 数据控制语言 grant, revoke, commit, rollback
```

## 2.insert

```sql
insert语句: 
insert into tablename[col1,…] values(val1,…);

--插入全部列
	insert into dept values(51,'51name','51loc');
		
--插入部分列
	insert into dept(deptno, dname) values(55, '55name');
		  	
--隐式插入null
	insert into dept(deptno,dname) values(52,'52name');
			
--显示插入null
	insert into dept(deptno,dname,loc) values(53,'53name',null);
      
--&符号的使用:
    insert into dept(deptno, dname, loc) values(&t1, &t2, &t3);
          
拷贝表结构:
    create table tname_YYYY_MM_DD as select * from tname_xxxxx where 1=2;  
    ---where条件为假, 只拷贝表结构，不拷贝数值，也可加条件只拷贝部分数据
      
批量插入:
    insert into tname_bak select * from tname where .....;
```

## 3.update

```sql
update语句: update tablename set col1=val1, col2=val where  cond;

--修改emp表的员工名字为TOM_CAT的员工的薪水为原有薪水加100
	update emp set sal=sal+100 where ename='TOM_CAT';
       
--修改emp表的员工名字为TOM_CAT的员工的薪水为原有薪水加空
    update emp set sal=null where ename='TOM_CAT';
  注意: 在update的时候, null可以使用等号
  注意: 在update的时候, 一定要使用where条件, 否则会修改表中所有的记录
```

## 4.delete

```sql
delete语句: delete from tablename where cond;
   delete from emp where ename='TOM_CAT';
   delete from dept where ename = &dpt;
     注意: 在使用delete删除的时候一定要有where条件, 否则会删除整个表的记录
       
--delete和truncate的区别: 
	1. delete逐条删除表"内容", truncate先摧毁表再重建。
	(由于delete使用频繁，Oracle对delete优化后delete快于truncate)

	2. delete 是DML语句, truncate是DDL语句
	DML语句可以闪回(flashback), DDL语句不可以闪回
	（闪回:做错了一个操作并且commit了, 对应的撤销行为）
		
	3. 由于delete是逐条操作数据，所以delete会产生碎片，truncate不会产生碎片。
	（同样是由于Oracle对delete进行了优化, 让delete不产生碎片）。
	两个数据之间的数据被删除, 删除的数据——碎片, 整理碎片, 数据连续, 行移动
		
	4. delete不会释放空间, truncate会释放空间
				用delete删除一张10M的表, 空间不会释放。而truncate会。所以当确定表不再使用，应truncate
		
	5. delete可以回滚rollback, truncate不可以回滚rollback
		
实验验证一些delete和truncate
	通过实验比较, truncate删除的效率比delete快.
	打开时间回显: SQL> set timing on;
	关闭时间回显: SQL> set timing off;
```

## 5.列操作

```sql
1.增加列：
alter table tableName add columnName varchar(30);

2.1. 修改列类型：
alter table tableName alter column columnName varchar(4000);

2.2. 修改列的名称：
alter table tbl rename column columnName1 to columnName2;

3.删除列：
alter table tableName drop column columnName;   
```

```sql
增加一个列
	alter table tbl add email varchar2(30);
修改列属性
	alter table tbl modify email varchar2(40);
重命名列
	alter table tbl rename column email to address;
删除列
	alter table tbl drop column address;
```





保存点:使用保存点的目的是把一个大的事物分成几段进行保存 

```sql
以实验的方式说明保存点的作用: 
create table testsp (tid number, tname varchar2(20)); 
insert into testsp values(1, 'Tom');
insert into testsp values(2, 'Mary');
savepoint aaa;--设置保存点
insert into testsp values(3, 'Moke');
savepoint bbb;--设置保存点
update testsp set tname='tomson' where tid=1;
delete from testsp where tid=1;
rollback to savepoint bbb;
SQL> select * from testsp;

			       TID TNAME
			---------- --------------------
			         1 Tom
			         2 Mary
			         3 Moke
rollback to savepoint aaa;--此时不能再回退到bbb

rollback ;--事务结束
select * from testsp;
**说明: 当执行commit或者rollback后保存点就会全部无效了.
```



# 四、创建和管理表

## 1.事务

```sql
事物的概念:数据库事务, 是由有限的数据库操作序列组成的逻辑执行单元,这一系列操作要么全部执行, 要么全部放弃执行.

数据库事务由以下的部分组成:
		a 一个或多个DML语句
		b 一个 DDL(Data Definition Language – 数据定义语言) 语句
		c 一个 DCL(Data Control Language – 数据控制语言) 语句
	
事务的特点：要么都成功，要么都失败。
	 
事物开始: 事物以DML语句开始, 执行一系列的数据插入或者是修改操作
	 
事物结束: 
	1 提交结束: 
		显示提交： commit;
		隐式提交: 执行了DDL语句(如create了一个表), 正常退出
				  
	2 回滚结束：
		显示回滚: rollback;
		隐式回滚: 断电, 宕机, 异常退出等

事物的特性:原子性、一致性、隔离性、持久性   
 
事物的隔离级别: 了解oracle是读已提交数据, mysql是可重复读.

	数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题. 
	一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱
																					
SQL99定义4中隔离级别：	
1. 	Read Uncommitted	读未提交数据。
							
2.	Read Commited		读已提交数据。		（Oracle默认）
							
3.	Repeatable Read		可重复读。		（MySQL默认）
		
4.	Serializable  序列化、串行化。（查询也要等前一个事务结束）

这4种MySQL都支持	
Oracle支持的隔离级别： Read Commited（默认）和Serializable，以及Oracle自定义的Read Only三种。
Read Only：由于大多数情况下，在事务操作的过程中，不希望别人也来操作，但是如果将别人的隔离级别设置为Serializable（串行），但是单线程会导致数据库的性能太差。是应该允许别人来进行read操作的。

```

## 2.表的基本操作

```sql
基本的数据存储集合，由行和列组成。表名和列名遵循如下命名规则：
	必须以字母开头
	必须在 1–30 个字符之间
	必须只能包含 A–Z, a–z, 0–9, _, $, 和 #
	必须不能和用户定义的其他对象重名
	必须不能是Oracle 的保留字
	Oracle默认存储是都存为大写
	数据库名只能是1~8位，datalink可以是128位，和其他一些特殊字符

```

```sql
--创建表的语句: 	
	create table tbl(id number, name varchar2(20));
    insert into tbl values(01, 'xiaoliu');
      
--在创建表的时候为某一列设置默认值
      create table tbl(id number, name varchar2(20), hiredate date default sysdate);
      insert into tbl(id, name) values(02, 'xiaohong');  ---若没有插入hiredate的值, 则使用默认值
      
--通过已有的表创建一个表, 相当于表结构的复制
      create table tbl_bak as select * from tbl where 1=2;     
			
--表名的重命名
		rename t1 to t2;

--删除表
		drop table tbl;       --删除的表可以闪回
		drop table tbl purge; --purge的作用删除不经过回收站, 删除的表不可以闪回
		

表的闪回:删除的表恢复回来
--实现过程: 
	1 create table tbl(id number, name varchar2(20));
	2 drop table tbl;
	3 select * from tab;    ---看tname那一列
	4 show recyclebin;      ----看ORIGINAL NAME那一列
	5 flashback table tbl to before drop;
	
  假如: drop table tbl purge; 则不能闪回了
  1 drop table tbl purge;
  2 select * from tab;
  3 show recyclebin;
  4 flashback table tbl to before drop;
```

## 3.表的约束

表的约束（5种）：
		○ 检查 (值是否符合预设的规则)
		○ 非空 (not null)
		○ 唯一 (不能重复)
		○ 主键（非空+唯一）
		○ 外键 (取值必须在另外一个表中存在)

```sql
//为测试方便, 新建一个表, 与dept一样, 并添加主键(做就要是为了测试外键)
  create table dept_bak as select * from dept;
  alter table dept_bak add constraint pk_dept_bak primary key (DEPTNO);
--使用约束的例子:
	create table student(
		id number constraint pk_student primary key,   ---主键(非空唯一)
		name varchar2(30)  not null,       --非空
		email varchar2(30) unique,       --唯一
		sex varchar2(10) check(sex in ('男','女')),    --check约束
		sal number check(sal>10000),    --check约束
		deptno number(2) references dept_bak(deptno) on delete set null  --当dept_bak表的数据被删除以后, 该列设置为null
);

--给hiredate设置默认值
  	alter table student add hiredate date default sysdate;
  
1 验证主键: 分两方面验证, 非空和唯一
	先正常插入一条记录: 
    	insert into student(id, name, email, sex, sal, deptno) values(1000, 'xiaohong', 'helloworld@163.com', '女', '10001', 10);
    验证主键唯一性: 
    	insert into student(id, name, email, sex, sal, deptno) values(1000, 'xiaohong', 'helloworld@163.com', '女', '10001', 10);--报错, 1000与刚刚插入成功的重复了
    验证主键非空:
    	insert into student(id, name, email, sex, sal, deptno) values(null, 'xiaohong', 'helloworld@163.com', '女', '10001', 10);
  
2 验证非空: 使用name来进行验证
      insert into student(id, name, email, sex, sal, deptno) values(1001, null, 'hello@163.com', '女', '10001', 10);
   
3 验证唯一性: 通过email进行验证  
      insert into student(id, name, email, sex, sal, deptno) values(1001, 'xiaoliu', 'helloworld@163.com', '女', '10001', 10);              
   
4 验证check约束: 使用sex和sal进行验证
      insert into student(id, name, email, sex, sal, deptno) values(1001, 'xiaoliu', 'xiaofang@163.com', '无', '10001', 10);   --sex违反check条件,sex只能取'男','女'
      insert into student(id, name, email, sex, sal, deptno) values(1001, 'xiaoliu', 'xiaoyuan@163.com', '女', 9000, 10);    --sal违反check条件,sal>10000               
      
5 验证外键
      insert into student(id, name, email, sex, sal, deptno) values(1002, 'xiaoliu', 'xiaohua@163.com', '女', '10001', 11);   ---dept表中不存在deptno为11的部门编号
       
	a--cascade 级联删除, 主表记录删除的时候, 子表数据跟着删除
	b--drop table dept_bak cascade constraints;
	c--set null  设置为null, 主表删除的时候，子表该字段设为null
	d--默认方式, 主表删除的时候, 如果子表引用了该字段的数据, 不能删除, 先删子表, 后删主表
```

## 4. 练习

```sql
1 查询emp表中工资在5-8的员工信息:(top-N问题)
	select rownum, e.* from emp e order by sal;  ---rownum不是有序的
	select e.* from emp order by sal;
	select rownum rn, e.* from (select e.* from emp e  order by sal) e;
	
--最后结果
	  select *
	    from (select rownum rn, e.* from (select e.* from emp e order by sal) e) d
	   where d.rn >= 5
	     and d.rn <= 8;
	注意点:
		rownum是在集合第一次产生的时候生成的.
		可以将查询的结果看成一个表来用.
		
2 部门工资大于本部门平均工资的员工信息(deptno empno ename sal avg(sal))
  2.1 先查询10号部门:
      使用子查询:
		   select e.deptno,
		       e.empno,
		       e.ename,
		       e.sal,
		       (select avg(sal) from emp where deptno = 10) 
		  from emp e
		 where e.deptno = 10
		   and e.sal > (select avg(sal) from emp where deptno = 10);
     推广到所有部门:
		select e.deptno,
		       e.empno,
		       e.ename,
		       e.sal,
		       (select avg(sal) from emp where deptno = e.deptno)
		  from emp e
		 where e.sal > (select avg(sal) from emp where deptno = e.deptno)
		 order by e.deptno;
   
    使用多表查询:
    	先查询每个部门的平均工资:
    		select deptno, avg(sal) from emp group by deptno;
		将上述结果集看成一个表, 与emp做多表查询
		select e.deptno, e.empno, e.ename, e.sal, d.avgsal
		  from emp e,
		       (select deptno, avg(sal) avgsal from emp group by deptno) d
		 where e.deptno = d.deptno
		   and e.sal > d.avgsal
		 order by e.deptno;

3 从emp表中查询, 结果显示如下的格式:
    Total       1980       1981       1982       1987
---------- ---------- ---------- ---------- ---------
     14          1         10          1          2
        
   select count(empno) "Total",
           from emp; 
   
   select hiredate from emp;  
   
   select to_char(hiredate, 'YYYY') from emp;
   
   select decode(to_char(hiredate, 'YYYY'), '1980', 1, 0) from emp;
   
   select sum(decode(to_char(hiredate, 'YYYY'), '1980', 1, 0)) from emp;
   
   合成一步:
   select count(empno) "Total",
          sum(decode(to_char(hiredate, 'YYYY'), '1980', 1, 0)) "1980",
          sum(decode(to_char(hiredate, 'YYYY'), '1981', 1, 0)) "1981",
          sum(decode(to_char(hiredate, 'YYYY'), '1982', 1, 0)) "1982",
          sum(decode(to_char(hiredate, 'YYYY'), '1987', 1, 0)) "1987"
    from emp;
```

## 5、视图

**从表中抽出的逻辑上相关的数据集合。**

所以：1. 视图基于表。2. 视图是逻辑概念。3. 视图本身没有数据。

```sql
	如何创建视图:
		create or replace view vw_emp as select * from emp;
		create or replace view vw_emp as select empno, ename, job from emp where deptno=20;
	    create or replace view vw_emp_dept as select e.deptno, d.dname, e.ename, e.job from emp e, dept d where e.deptno=d.deptno;
		
		创建只读视图:
		create or replace view vw_emp as select * from emp with read only;
		
		view_name from user_views;
	如何删除视图:
		drop view vw_emp;
	
	使用视图的目的:
		可以简化查询
		可以限制用户对某些数据的访问
	注意点: 
		不要通过视图去修改表的数据.
```

## 6、索引

```sql
什么是索引?
		索引也是数据库的一个对象, 索引主要是用于表, 目的是提高查询的效率.
	如何创建索引?
		create index idx_mytest on mytest(id);
		create unique index idx_mytest on mytest(id);
	查询创建的索引:	
		select index_name from user_indexes;
	如何删除索引?
		drop index idx_mytest;
		
	使用索引注意点?
		使用索引的列值的分布要广泛, 重复的概率非常低, 唯一最好.
		表的主键就是索引,而且是唯一索引.
	
	索引的原理?
		若一个表有索引, 则oracle会在内部维护一个索引表, 查询的时候要使用
		索引的列, 优先会到索引表中去查,通过索引的列找到对应的行地址, 找到行地址
		就可以找到数据.
		索引表中的列的值是有序的.
	
	通过实验验证索引?
	有索引的情况:
	SQL> select * from mytest where id=8999;

        ID NAME
	---------- --------------------
	   8999 xiaohong_8999

	Elapsed: 00:00:00.01
	
	删除索引以后:
	Elapsed: 00:00:00.21
	SQL> select * from mytest where id=8999;

	        ID NAME
	---------- --------------------
	      8999 xiaohong_8999

	Elapsed: 00:00:00.03
```

## 7、序列

```sql
1 序列的用处:
		由于表的主键要求是非空且唯一的, 为了保证主键是非空和唯一的, 可以使用序列.
	2 如何创建序列
		 create sequence seq_mytest;
		 select xxxx_name from user_xxxxs;--查询视图索引序列公式
		 select sequence_name from user_sequences;
	3 序列的属性
		currval 和 nextval, 但是第一次使用的时候先要取nextval的值.
	4 如何删除序列	
		drop sequence seq_mytest;

```

## 8.同义词

```sql
	1 什么是同义词:
		同义词就是别名.
		
	2 同义词使用的场合.--在访问端使用
	  xiaohong想访问scott用户的emp表:
	  让scott用户给xiaohong赋权限: 对emp表的select权限:
	  	grant select on emp to xiaohong;
	  	
	  	使用xiaohong用户登录数据库: sqlplus xiaohong/xiaohong@oracle;
	  	SQL> select * from scott.emp;
	  	假如在访问scott.emp表的时候, 不想写scott., 应该给scott.emp建立同义词.  
	  
	 3 如何创建同义词:
	 	create synonym emp for scott.emp;
	 	select synonym_name from user_synonyms;	--查询同义词 	 
	 	 
	/*如何创建一个新的oracle用户
		使用sys用户创建新的用户和给这个新用户添加权限:
			create user xiaohei identified by xiaohei;
			grant connect, resource to xiaohei;
			grant create synonym to xiaohei;*/
	4 删除同义词:
		drop synonym emp;
```



# MySQL

# 一、基础知识

mysql和oracle的组织结构

![image-20210921145354868](E:\typroa_pic\image-20210921145354868.png)



```mysql
登陆mysql服务
	a 用root身份启动mysql服务
		service mysql start
			

	b 查看mysql服务是否已经启动
		ps -u mysql
		ps -ef | grep mysql
			
	c  停止mysql服务
		service mysql stop
		  
	d 登陆mysql服务
			 
		注意: 密码从/root/.mysql_secret文件中获取
	      
	      登陆成功后, 修改密码:
	      mysql> set password=password('123456');
    
    注意: 若无法正常登陆, 可以用root用户杀死mysql服务, 重新启动.
    	  
	如何将oracle用户加入到sudo当中:
		打开 /etc/sudoers, 添加oracle ALL=(ALL) ALL
```

# 二、基本操作

## 1. 数据库的增删查改

### 1.1 创建数据库

```mysql
创建一个名称为mydb1的数据库。(默认为latin1)
	create database mydb1;
创建一个使用utf-8字符集的mydb2数据库。
	create database mydb2 character set utf8;
创建一个使用utf-8字符集，并带校对规则的mydb3数据库。会对存入的数据进行检查。
	create database mydb3 character set utf8 collate utf8_general_ci;
```

### 1.2 查看数据库

```mysql
显示所有数据库
	show databases;
显示创建数据库的语句信息
	show create database mydb2; 
	“ ` ”（波浪键），表示反引号，默认情况下，反引号括起来的字符串，区分大小写。
	show create database mydb1;
注意 ：mysql默认语言集是latin1，每次在创建数据库的时候应指定字符集。Oracle是在安装时，即指定了字符集。
```

### 1.3 修改数据库

```mysql
修改mydb1的字符集为utf8(不能修改数据库名)
	alter database mydb1 character set utf8;	
```

### 1.4 删除数据库

```mysql
删除数据库mydb3
		drop database mydb3;
```

## 2. 表的增删查改

```mysql
--对表本身进行操作：创建，查看，修改，删除

	在创建表之前要先指定使用哪个库, 先查看一下有哪些库:
		--查看有哪些库:
			show databases;
		--使用指定的库:
			use mysql;
```

### 2.1 创建表

```mysql
	create table t1 (id int, name varchar(20))
	但此时会报错误：ERROR 1046 (3D000): No database selected。注意，在mysql中对表操作前，必须先选择所使用的数据库。
		use mydb2;

	查看当前使用的是哪个库:
		status  或者 select database() from dual;
			
	查看当前选择的数据库中的表：
		show tables;
	查看表结构：
		desc tablename;
在Mysql中显示多行数据应该在查询语句结尾处添加 \G来替换结束标记“；”
	查看创建表的语法：
		show create table t1;		#ENGINE=InnoDB 默认指定的存储引擎 innoDB。

```

mysql中的数据类型：

![img](E:\typroa_pic\clip_image002-1632210786845.jpg)

```mysql
bit   1位　   可以指定位数，如：bit(3)

int   2字节   可以指定最大位数，如：int<4>　最大为4位的整数

float  2个字节　可以指定最大的位数和最大的小数位数，如：float<5,2> 最大为一个5位的数，小数位最多2位 

double　4个字节　可以指定最大的位数和最大的小数位数，如：float<6,4> 最大为一个6位的数，小数位最多4位

char　 必须指定字符数,如char(5) 为不可变字符　即使存储的内容为'ab',也是用5个字符的空间存储这个数据

varchar　必须指定字符数,如varchar(5) 为可变字符　如果存储的内容为'ab',占用2个字符的空间；如果为'abc',则占用3个字符的空间

text: 大文本(大字符串)

blob：二进制大数据　如图片，音频文件，视频文件

date: 日期　如：'1921-01-02'

datetime: 日期+时间　如：'1921-01-02 12:23:43'

timeStamp: 时间戳，自动赋值为当前日期时间

创建一个员工表：

create table employee(empno int, ename varchar(20), sal int);
```

### 2.2 查看表

```mysql
查看所有的表：
		show tables;
	查看指定表的创建语句
		show create table employee;
		注意，mysql表名称区分大小写, 对列名不区分大小写
	显示指定表的结构：
		desc employee;
```

### 2.3 修改表 

```mysql
更改表名：    
	rename table employee to worker;
        
增加一个字段：
	alter table employee add column height double;   （column关键字在Oracle中，添加则语法错误）
	
修改一个字段：
	alter table employee modify column height float;
	
删除一个字段：
	alter table employee drop column height;
	
修改表的字符集:
	alter table employee character set gbk;
```

### 2.4 删除表

```mysql
删除employee表
	drop table employee;	(MySQL中不能使用purge，添加会出现语法错误)
```

## 3. 数据的增删查改

### 3.1 create数据

```mysql
创建一个员工表，新建employee表并向表中添加一些记录：
create table employee(
id int,
name varchar(20),
sex int,
birthday date,
salary double,
entry_date date,
resume text
);

insert into employee values(1,'张三',1,'1983-04-27',15000,'2012-06-24','一个大牛');

insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(2,'李四',1,'1984-02-22',10000,'2012-07-24','一个中牛');

insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(3,'王五',0,'1985-08-28',7000,'2012-08-24','一个小虾');

注意: 若在插入的时候报错, 可以查看当前用户字符集是否是latin1.

```

### 3.2 Retrieve数据

```mysql
select id, name as "名字", salary "月薪", salary*12 年薪  from employee where id >=2;

```

### 3.3 update数据

```mysql
将所有员工薪水都增加500元。
		update employee set salary=salary+500;
将王五的员工薪水修改为10000元，resume改为也是一个中牛
		update employee set salary=10000, resume='也是一个中牛' where name='王五';

```

### 3.4 delete数据

```mysql
删除表中姓名为王五的记录。
		delete from employee where name='王五';		【注意from不能省略】
	删除表中所有记录。
		delete from employee; 
	使用truncate删除表中记录。
		truncate employee;--无条件 效率高
```

## 4. 分组查询

```mysql
 top-N问题:
	按math成绩从小大的排序, 求math成绩在5-8名的
	select * from student order by math limit 4, 4;
		limit后面的两个数字的意思:
		第一个4: 表示要跳过前面几个
		第二个4: 表示连续取几个.
			

分组查询部分.

	#查出各个班的总分和最高分
		select class_id, sum(chinese+english+math), max(chinese+english+math) from student group by class_id;
		
	#求各个班级英语的平均分
		select class_id, avg(english) from student group by class_id;
		
	#查询出班级总分大于1300分的班级ID
		select class_id, sum(chinese+english+math) "总分" from student group by class_id having 总分>1300;
			
    注意: having后面若是用"总分"不可以, 但是不加""可以.
        在oracle数据库中, having后面不可以使用别名, mysql可以使用别名(若是中文不要加"")
        
        select colname | * from tablename where cond group by colname having cond order by ...;

```

## 5. 时间和日期函数

```mysql
MySQL里面时间分为三类：时间、日期、时间戳(含有时分秒的sysdate)。
如执行：select now(), year(now()) 年, month(now()) 月, day(now()) 日, date(now());

select CURRENT_DATE() , CURRENT_TIME(),  CURRENT_TIMESTAMP() from dual;

select date_add(now(), INTERVAL 2 year) from dual;	#增加两年
	select date_add(now(), INTERVAL -1 day) 昨天, now() 今天, date_add(now(), INTERVAL +1 day) 明天;
select date_add(now(), interval -1 day) 昨天, date, date_add(now(), interval +1 day) 明天;
注意: 上述语句中的函数名, INTERVAL不区分大小写, day, month, year也可以用大写.

```

## 6. 数学相关函数

```mysql
ABS (number2 ) #绝对值

BIN(decimal_number ) #十进制转二进制

CEILING (number2 ) #向上取整

coNv(number2,from_base,to_base) #进制转换

FLOOR (number2 ) #向下取整

FORMAT (number,decimal places ) #保留小数位数

HEX(DecimalNumber ) #转十六进制

LEAST (number , number2 [..]) #求最小值

MOD (numerator ,denominator ) #求余

RAND([seed])
```

## 7. 多表查询

```mysql
1 准备测试数据
	--将scott_data.sql文件的数据导入到mysql中
		mysql> source scott_data.sql#运行sql脚本  source  文件路径
		
2 交叉连接---相当于笛卡尔积
	 select e.*, d.* from emp e cross join dept d;

3 自连接
  查询emp表和dept表的所有信息: 
  
	--SQL99: 
	 	select e.*, d.* from emp e inner join dept d on e.deptno=d.deptno;
	 	其中inner可以省略
	 	
	--oracle写法: 
	 	select e.*, d.* from emp e, dept d where e.deptno=d.deptno;
	 	总结: 
           [,]---->[inner join]
     	   [where]----->[on]

	注意: 不能显示40号部门的信息, 此时需要使用外连接
	
4 外连接
  左外连接:
  	select e.*, d.* from emp e left outer join dept d on e.deptno=d.deptno;
  
  右外连接:
		select e.*, d.* from dept d right outer join emp e on e.deptno=d.deptno;
	
		【注意】SQL99中，外链接取值与关系表达式=号左右位置无关。取值跟from后表的书写顺序有关。 
		"xxx left outer join yyy"  则为取出xxx的内容。
		"xxx right outer join yyy" 则为取出yyy的内容
```

### 7.1 练习

```mysql
对比练习:

1 查询员工信息,员工号,姓名,月薪,部门名称
	select e.empno, e.ename, e.sal, d.dname from emp e inner join dept d on e.deptno=d.deptno;
	 select e.empno, e.ename, e.sal, d.dname from emp e, dept d where e.deptno=d.deptno;

	   [,] ---->inner join
	   [where] ----->on 

2 统计各个部门员工总人数-要求显示部门名称
	select d.deptno, d.dname, count(e.empno) 
	from emp e inner join dept d 
		on e.deptno=d.deptno group by d.deptno, d.dname;

	select d.deptno, d.dname, count(e.empno) 
		from emp e,  dept d 
			where e.deptno=d.deptno group by d.deptno, d.dname;

显示40号部门的信息----需要使用外连接
	oracle的写法: ----不支持
		select d.deptno, d.dname, count(e.empno) from emp e, dept d where e.deptno(+)=d.deptno group by d.deptno; ---不支持此种写法

外连接:	
	右外连接:	
		select d.deptno, d.dname, count(e.empno) 
			from emp e right outer join dept d 
				on e.deptno=d.deptno group by d.deptno, d.dname;		

	左外连接:
		SELECT d.deptno, d.dname, COUNT(e.empno) 
			FROM dept d LEFT OUTER JOIN emp e 
				ON e.deptno=d.deptno GROUP BY d.deptno, d.dname;

与oracle比较:
	  	mysql不支持oracle那样的外连接的写法, 需要使用right | left [outer] join 的写法
	  	,---->right|left [outer] join
	  	where---->on
```

## 8. 字符串相关函数

```mysql
CHARSET(str)  #返回字串字符集

CONCAT (string2 [.…. 1)  #连接字串
                 
INSTR (string ,substring )  #返回substring在string中出现的位置,没有返回O
                 
UCASE (string2 )  #转换成大写
                 
LCASE (string2 )  #转换成小写
                 
LEFT (string2 ,length )#从string2中的左边起取length个字符
                 
LENGTH (string )  #string长度
                 
REPLACE (str ,search_str ,replace_str )  #在str中用replace_str替换search_str
                 
STRCMP (string1 ,string2 )  #逐字符比较两字串大小,
                 
SUBSTRING (str , position [,length ])  #从str的position开始,取length个字符
                 
LTRIM(string2 ) RTRIM(string2 )   #trim去除前端空格或后端空格
```



```mysql
日期转字符串：
	在MySQL中没有to_date函数，进行日期转换需使用date_format()来代替。
	select date_format('2013-5-11', 'yyyy-mm-dd') from dual;  #在Oracle中的‘yyyy-mm-dd’MySQL下不支持。
	select date_format(now(), '%Y-%m-%d') from dual; 			 #y和Y不一样。
	select date_format(now(), '%Y-%c-%d %h:%i:%s') from dual; 	 #c和m、M不一样
	所以yyyy-mm-dd hh24:mi:ss格式在MySQL中对应'%Y-%c-%d %h:%i:%s'
	
字符串转日期：
	select str_to_date('2013-6-04 05:14:15' , '%Y-%c-%d %h:%i:%s') from dual;

```

## 9. 自连接

```mysql
查询员工、老板信息，显示: xxx的老板是yyy 
分析: 可以将emp表当成两个表来用, 一个是员工表 e, 一个是老板表 b
	1 mysql不支持用||连接两个字符串			
		
	2 使用concat函数
		select concat(e.ename, '的老板是', b.ename) from emp e, emp b where e.mgr=b.empno;
		select concat(e.ename, '的老板是', b.ename) from emp e inner join emp b on e.mgr=b.empno;
		
	3 若要显示KING的信息, 需要使用外连接
		#mysql不支持nvl函数					
		使用ifnull函数
		左外连接:
			select concat(e.ename, '的老板是', b.ename) from emp e left outer join emp b on e.mgr=b.empno;
			select concat(e.ename, '的老板是', ifnull(b.ename, 'HIMSELF')) from emp e left outer join emp b on e.mgr=b.empno;
		右外连接:
			select concat(e.ename, '的老板是', ifnull(b.ename, 'HIMSELF')) from emp b right outer join emp e on e.mgr=b.empno;
					
```

## 10. 表的约束

```mysql
表的约束:
		定义主键约束　primary key:	不允许为空，不允许重复
		定义主键自动增长　auto_increment
		定义唯一约束　unique
		定义非空约束　not null
		定义外键约束　constraint ordersid_FK foreign key(ordersid) references orders(id)
		删除主键：alter table tablename drop primary key ;

准备两个表:(下面的建表语句在执行的时候若不能正常执行, 可以尝试把tab去掉)
create table class (
id INT(11) primary key auto_increment,
name varchar(20) unique
);

create table student (
id INT(11) primary key auto_increment, 
name varchar(20) unique,
passwd varchar(15) not null,
classid INT(11),
constraint stu_classid_FK foreign key(classid) references class(id)
);

向class表中插入两条数据:
	insert into class(name) values('音乐');
	insert into class(name) values('体育');
	insert into class(id, name) values(5, '美术');
	insert into class(name) values('文化');
	注意: 要插入的是部分列, 一定要在class表名后面写上列名, 表示要插入哪些列
	      由于class表的id是主键, 可以不用显示的插入主键的值, mysql会自动插入,而且会自动增长,确保不会重复.

向student表中插入数据:	
  正常插入一条记录:
	insert into student(name, passwd, classid) values('xiaohong', 'xxxxxx', 1);
	1 测试主键的非空性
		insert into student(id, name, passwd, classid) values(null, 'xiaowen', 'xxxxxx', 1);
			注意: 若给主键插入一个null, mysql会自动插入一个有效的值, 所以mysql的主键肯定不会为空
			
	2 测试主键的唯一性约束
		insert into student(id, name, passwd, classid) values(1, 'xiaoliu', 'xxxxxx', 1);
		----->ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'
	
	3 测试name列的唯一性
		insert into student(name, passwd, classid) values('xiaohong', 'xxxxxx', 2);
		-----> ERROR 1062 (23000): Duplicate entry 'xiaohong' for key 'name'
		
		insert into student(name, passwd, classid) values(null, 'xxxxxx', 2);
		注意: name为unique约束, 只是不能重复, 但是可以为空
	
	4 测试passwd的非空约束
		insert into student(name, passwd, classid) values('xiaohua', null, 2);
		-----> ERROR 1048 (23000): Column 'passwd' cannot be null
		
	5 测试classid的外键约束
		insert into student(name, passwd, classid) values('meizi', 'mmmm', 10);
		----->OREIGN KEY (`classid`) REFERENCES `class` (`id`))
		在class表中没有id为10的列的值.
```

# 三、中文乱码问题

```mysql
mysql -uroot -p123456 --default_character_set=gbk 
#指定字符集登录数据库
```

原因：

第一类:

1. 使用utf8方式登录数据库后,若insert了数据,使用gbk方式登录去查看则不能正常显示,显示乱码;

2. 使用gbk方式登录数据库后,若insert了数据,则使用utf8方式登录去查看则不能正常显示,显示乱码;
3. 应该是使用哪种方式插入的就用哪种方式去select查看.

第二类: 操作系统本身必须支持中文的显示
第三类:  linux客户端工具若不支持中文显示也会显示乱码.



# 四、MYSQL数据库API编程

## 1.makefile文件  ---编译MYSQL

```makefile
src = $(wildcard *.c)
target = $(patsubst %.c, %, $(src))
inc_path = /usr/include/mysql/
lib_path = /usr/lib64/mysql/
all: $(target)
%:%.c
	gcc $< -o $@ -I$(inc_path) -L$(lib_path) -lmysqlclient -lstdc++ -lpthread -ldl -lrt
clean:
	-rm -rf $(target)
.PHONY: all clean
```



## 2.mysql_init

```c
MYSQL *mysql_init(MYSQL *mysql) 
```

**描述**

分配或初始化与mysql_real_connect()相适应的MYSQL对象。如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址。如果mysql_init()分配了新的对象，当调用mysql_close()来关闭连接时。将释放该对象。

**返回值**

初始化的MYSQL*句柄。如果无足够内存以分配新的对象，返回NULL。

**错误**

在内存不足的情况下，返回NULL。

```c
//mysql初始化
#include <stdio.h>
#include <stdlib.h>
#include "mysql.h"

int main()
{
	//MYSQL *mysql_init(MYSQL *mysql) 
	MYSQL *mysql = mysql_init(NULL);
	if(mysql==NULL)
	{
		printf("mysql init error\n");
		return -1;
	}
	printf("mysql init ok\n");

	return 0;
}
```

## 3.mysql_connect

```c
MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) 
```

**描述**

mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数之前，mysql_real_connect()必须成功完成。

**返回值**

如果连接成功，返回MYSQL*连接句柄。如果连接失败，返回NULL。对于成功的连接，返回值与第1个参数的值相同。

**错误**

·     CR_CONN_HOST_ERROR 

无法连接到MySQL服务器。

·     CR_CONNECTION_ERROR 

无法连接到本地MySQL服务器。

·     CR_IPSOCK_ERROR 

无法创建IP套接字。

·     CR_OUT_OF_MEMORY 

内存溢出。 

·     CR_SOCKET_CREATE_ERROR 

无法创建Unix套接字。

·     CR_UNKNOWN_HOST 

无法找到主机名的IP地址。

·     CR_VERSION_ERROR

```c
//mysql连接数据库
#include <stdio.h>
#include <stdlib.h>
#include "mysql.h"

int main()
{
	//初始化
	//MYSQL *mysql_init(MYSQL *mysql) 
	MYSQL *mysql = mysql_init(NULL);
	if(mysql==NULL)
	{
		printf("mysql init error\n");
		return -1;
	}
	printf("mysql init ok\n");

	//连接mysql数据库
	//MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) 
	MYSQL *conn = mysql_real_connect(mysql, "192.168.10.145", "root", "123456", "mysql", 0, NULL, 0);//如果成功返回值conn和mysql参数是同一个值
	if(conn==NULL)
	{
		printf("mysql_real_connect error,[%s]\n", mysql_error(mysql));
		return -1;
	}
	printf("connect mysql OK, [%p], [%p]\n", mysql, conn);


	//关闭数据库连接
	mysql_close(conn);
	
	return 0;
}

```

## 4.mysql_query

```c
int mysql_query(MYSQL *mysql, const char *query) 
```

**描述**

执行由“Null终结的字符串”查询指向的SQL查询。正常情况下，字符串必须包含1条SQL语句，而且不应为语句添加终结分号（‘;’）或“\g”。如果允许多语句执行，字符串可包含多条由分号隔开的语句。

mysql_query()不能用于包含二进制数据的查询，应使用mysql_real_query()取而代之（二进制数据可能包含字符‘\0’，mysql_query()会将该字符解释为查询字符串结束）。

如果希望了解查询是否应返回结果集，可使用mysql_field_count()进行检查。

**返回值**

如果查询成功，返回0。如果出现错误，返回非0值。 

**错误**

·      CR_COMMANDS_OUT_OF_SYNC 

以不恰当的顺序执行了命令。 

·     CR_SERVER_GONE_ERROR 

MySQL服务器不可用。 

·     CR_SERVER_LOST 

在查询过程中，与服务器的连接丢失。 

·     CR_UNKNOWN_ERROR 

出现未知错误。 

```c
//mysql执行sql语句
#include <stdio.h>
#include <stdlib.h>
#include "mysql.h"

int main()
{
	//初始化
	//MYSQL *mysql_init(MYSQL *mysql) 
	MYSQL *mysql = mysql_init(NULL);
	if(mysql==NULL)
	{
		printf("mysql init error\n");
		return -1;
	}
	printf("mysql init ok\n");

	//连接mysql数据库
	//MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) 
	MYSQL *conn = mysql_real_connect(mysql, "192.168.10.145", "root", "123456", "scott", 0, NULL, 0);
	if(conn==NULL)
	{
		printf("mysql_real_connect error,[%s]\n", mysql_error(mysql));
		return -1;
	}
	printf("connect mysql OK, [%p], [%p]\n", mysql, conn);

	//执行sql语句
	//int mysql_query(MYSQL *mysql, const char *query) 
	char sSQL[255] = "insert into mytest values(1, 'xiaohuang')";
	int ret = mysql_query(conn, sSQL);
	if(ret!=0)
	{
		printf("mysql_query error, [%s]\n", mysql_error(mysql));
	}
	printf("mysql_query ok\n");

	//关闭数据库连接
	mysql_close(conn);
	
	return 0;
}

```

## 5.mysql_result

```c
MYSQL_RES *mysql_store_result(MYSQL *mysql) 
```

**描述**

对于成功检索了数据的每个查询（SELECT、SHOW、DESCRIBE、EXPLAIN、CHECK  TABLE等），必须调用mysql_store_result()或mysql_use_result()  。

一种方式是通过mysql_store_result()将整个结果集全部取回来。另一种方式则是调用mysql_use_result()初始化获取操作，但暂时不取回任何记录。视结果集的条目数选择获取结果集的函数。两种方法均通过mysql_fetch_row()来访问每一条记录

mysql_store_result()将查询的全部结果读取到客户端，分配1个MYSQL_RES结构，并将结果置于该结构中。

如果查询未返回结果集，mysql_store_result()将返回Null指针（例如，如果查询是INSERT语句）。

如果读取结果集失败，mysql_store_result()还会返回Null指针。通过检查mysql_error()是否返回非空字符串，mysql_errno()是否返回非0值，或mysql_field_count()是否返回0，可以检查是否出现了错误。

如果未返回行，将返回空的结果集。（空结果集设置不同于作为返回值的空指针）。

一旦调用了mysql_store_result()并获得了不是Null指针的结果，可调用mysql_num_rows()来找出结果集中的行数。

可以调用mysql_fetch_row()来获取结果集中的行，或调用mysql_row_seek()和mysql_row_tell()来获取或设置结果集中的当前行位置。

一旦完成了对结果集的操作，必须调用mysql_free_result()。 

**返回值**

具有多个结果的MYSQL_RES结果集合。如果出现错误，返回NULL。 

**错误**

如果成功，mysql_store_result()将复位mysql_error()和mysql_errno()。

·      CR_COMMANDS_OUT_OF_SYNC 

以不恰当的顺序执行了命令。 

·     CR_OUT_OF_MEMORY 

内存溢出。 

·     CR_SERVER_GONE_ERROR 

MySQL服务器不可用。 

·     CR_SERVER_LOST 

在查询过程中，与服务器的连接丢失。 

·     CR_UNKNOWN_ERROR 

出现未知错误。 

```c
//mysql获取结果集
#include <stdio.h>
#include <stdlib.h>
#include "mysql.h"

int main()
{
	//初始化
	//MYSQL *mysql_init(MYSQL *mysql) 
	MYSQL *mysql = mysql_init(NULL);
	if(mysql==NULL)
	{
		printf("mysql init error\n");
		return -1;
	}
	printf("mysql init ok\n");

	//连接mysql数据库
	//MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) 
	MYSQL *conn = mysql_real_connect(mysql, "192.168.10.145", "root", "123456", "scott", 0, NULL, 0);
	if(conn==NULL)
	{
		printf("mysql_real_connect error,[%s]\n", mysql_error(mysql));
		return -1;
	}
	printf("connect mysql OK, [%p], [%p]\n", mysql, conn);

	//执行sql语句
	//int mysql_query(MYSQL *mysql, const char *query) 
	char sSQL[255] = "select * from mytest";
	int ret = mysql_query(conn, sSQL);
	if(ret!=0)
	{
		printf("mysql_query error, [%s]\n", mysql_error(mysql));
	}
	printf("mysql_query ok\n");

	//获取列数
	//unsigned int mysql_field_count(MYSQL *mysql) 	
	//unsigned int num = mysql_field_count(conn);

	//获取结果集
	//MYSQL_RES *mysql_store_result(MYSQL *mysql) 
	MYSQL_RES *results = mysql_store_result(conn);
	if(results==NULL)
	{
		printf("mysql_store_result error,[%s]\n", mysql_error(mysql));
		return -1;
	}
	printf("mysql_store_result ok\n");


	int i = 0;
	//获取列数
	//	unsigned int mysql_num_fields(MYSQL_RES *result) 
	unsigned int num = mysql_num_fields(results);

	//获取表头信息---列名
	//MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result)
	MYSQL_FIELD *fields = mysql_fetch_fields(results);
	if(fields==NULL)
	{
		printf("mysql_fetch_fields error,[%s]\n", mysql_error(mysql));
		return -1;
	}
	//打印表头信息
	printf("+------+-----------+\n");
	for(i=0; i<num; i++)
	{
		printf("%s\t", fields[i].name);
	}
	printf("\n");
	printf("+------+-----------+\n");
	
	//获取结果集中每一行记录
	MYSQL_ROW row;
	while((row=mysql_fetch_row(results)))
	{
		for(i=0; i<num; i++)
		{
			printf("%s\t", row[i]);	
		}
		printf("\n");
	}
	printf("+------+-----------+\n");

	//释放结果集
	//void mysql_free_result(MYSQL_RES *result) 
	mysql_free_result(results);

	//关闭数据库连接
	mysql_close(conn);
	
	return 0;
}

```

## 6.MYSQL客户端编写

**mysql客户端编写思路分析:**

```c
1 mysql初始化--mysql_init
2 连接mysql数据库---mysql_real_connect
3 while(1)
  {
  	//打印提示符:write(STDOUT_FILENO, "mysql >", strlen("mysql >"));
  	//读取用户输入: read(STDIN_FILENO, buf, sizeof(buf))
  	//判断用户输入的是否为退出: QUIT quit exit EXIT
  	if(strncasecmp(buf, "exit", 4)==0 || strncasecmp(buf, "quit", 4)==0)
  	{
  		//关闭连接---mysql_close();
  		exit();
  	}
  	
  	//执行sql语句--mysql_query();
  	
  	//若不是select查询, 打印执行sql语句影响的行数--mysql_affected_rows();
  	if(strncasecmp(buf, "select", 6)!=0)
  	{
  		printf("Query OK, %d row affected", mysql_affected_rows());
  		continue;
  	}
  	
  	//若是select查询的情况
  		---//获取列数: mysql_field_count()
  	//获取结果集: mysql_store_result()
  		--获取列数: int mysql_num_fields();
  	//获取表头信息并打印表头信息:mysql_fetch_fields();
  		
  	//循环获取每一行记录并打印: mysql_fetch_row()
  	//释放结果集: mysql_free_result()
  	
  }
  
4 关闭连接: mysql_close();
```



```c
//模拟mysql客户端程序
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "mysql.h"

int main()
{
	//mysql初始化---mysql_init
	MYSQL *mysql = mysql_init(NULL);
	if(mysql==NULL)
	{
		printf("mysql_init error\n");
		return -1;
	}
	
	//连接数据库
	MYSQL *conn = mysql_real_connect(mysql, "localhost", "root", "123456", "scott", 0, NULL, 0);
	if(conn==NULL)
	{
		printf("connect mysql db error, [%s]\n", mysql_error(mysql));
		return -1;
	}
	
	//获取当前进程使用的字符集
	printf("before:[%s]\n", mysql_character_set_name(conn));
	
	//设置字符集为utf8格式
	mysql_set_character_set(conn, "utf8");
	printf("after:[%s]\n", mysql_character_set_name(conn));

	int i;
	int n;
	int ret;
	int num;
	char *p;
	char buf[1024];
	MYSQL_RES *results;
	MYSQL_FIELD *fields;
	MYSQL_ROW row;
	
	//进入循环等待用户输入sql语句并执行sql语句
	while(1)
	{
		//打印提示符
		write(STDOUT_FILENO, "mysql> ", strlen("mysql> "));
		
		//读取用户输入
		memset(buf, 0x00, sizeof(buf));
		read(STDIN_FILENO, buf, sizeof(buf));
		
		//1-去掉末尾的;
		p = strrchr(buf, ';');//从
		if(p!=NULL)
		{
			*p = '\0';
		}
		
		//2-去掉回车
		if(buf[0]=='\n') 
		{
			continue;
		}
		
		//去掉最前面的几个空格
		for(i=0; i<strlen(buf); i++)
		{
			if(buf[i]!=' ')
			{
				break;
			}
		}
		n = strlen(buf);
		memmove(buf, buf+i, n-i+1); //+1表示多拷贝一个\0
		printf("[%s]\n", buf);
		
		//若输入的是退出: exit EXIT quit QUIT
		if(strncasecmp(buf, "exit", 4)==0 || strncasecmp(buf, "quit", 4)==0)
		{
			mysql_close(conn);
			exit(0);
		}
		
		//执行sql语句
		ret = mysql_query(conn, buf);
		if(ret!=0)
		{
			printf("%s\n", mysql_error(conn));
			continue;
		}
		
		//若用户输入的不是select查询
		if(strncasecmp(buf, "select", 6)!=0)
		{
			printf("Query OK, %ld row affected\n", mysql_affected_rows(conn));
			continue;
		}
		
		//下面是select查询的情况	
		//获取结果集
		results = mysql_store_result(conn);
		if(results==NULL)
		{
			printf("%s\n", mysql_error(conn));
			continue;
		}
		
		//获取列数
		num = mysql_num_fields(results);
		
		//获取表头---列名
		fields = mysql_fetch_fields(results);
		if(fields==NULL)
		{
			printf("%s\n", mysql_error(conn));
			mysql_free_result(results);//释放内存
			continue;
		}
		//打印表头
		printf("+----------+-----------+\n");
		for(i=0; i<num; i++)
		{
			printf("%s\t", fields[i].name);
		}
		printf("\n");
		printf("+----------+-----------+\n");
		
		//循环获取每一行记录
		while(row=mysql_fetch_row(results))
		{
			for(i=0; i<num; i++)
			{
				printf("%s\t", row[i]);
			}
			printf("\n");
		}
		printf("+----------+-----------+\n");
		
		//释放结果集
		mysql_free_result(results);
	}
		
	//关闭数据库连接
	mysql_close(conn);
	
	return 0;
}
```

### 中文乱码问题：

```mysql
修改mysql_real_connect()参数，连接到表中有中文数据的数据库，如mydb2，执行程序，测试显示中文出现乱码。我们可以使用mysql_query函数来解决该问题。
	在 while (1) 之前使用 ret = mysql_query(mysql, "set names utf8"); 来设置查询属性(也可以加到while中)。表示在查询的时候使用utf8的形式进行查询。
或者mysql_set_character_set(mysql, "utf8");
获取当前使用的字符集:  const char *mysql_character_set_name(MYSQL *mysql)

```

# 五、事务

​	**MySQL的事务的默认自动提交的，每执行一个sql语句都自动commit**

​     **Oracle的事务是自动打开的(以你执行的一条DML语句为标志)，但每次执行需要手动commit**

```mysql
修改mysql为手工提交:
1 开启事务
	start transaction;
2 设置手工提交
	set autocommit=0;

1 开启事务
	start transaction;
2 设置自动提交
	set autocommit=1;
```

source